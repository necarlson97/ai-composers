import os
import glob
import yaml

from shutil import copyfile
import music21
import mido


class Corpus():
    """
    Performs the handling of the midi corpus folder
    can translate it to and from a form better understood
    by the ai, as well as to wavs, midi images, etc
    """

    # TODO define this dict
    corpus_dict = {}

    # Used for the maping of midi notes (21-110) to characters
    # Where in the Unicode table to start
    # 32-ascii, 9592-squares, 9872-fun symbols, 10240-braille
    char_start = 32

    def __init__(self):
        self.load_all()
        self.to_yaml()

        self.char_keyboard = {
            midi_note_num: chr(midi_note_num - 21 + self.char_start)
            for midi_note_num in range(21, 120)
        }

    def load_all(self):
        """
        Read the corpus midi files, loading the data into memory
        """
        with open('corpus/save.yaml', 'r') as file:
            self.corpus_dict = yaml.safe_load(file)

        for file in glob.glob("corpus/cleaned/*.mid"):

            filename = os.path.basename(file)

            # Create a dict (if not exists)
            self.corpus_dict.setdefault(filename, {})
            d = self.corpus_dict[filename]

            # TODO REMOVE
            d.pop("song", None)

            # Get info from filename (movement could be none)
            has_file_info = all([
                k in d for k in ['composer', 'song_name', 'movement']
            ])
            if not has_file_info:
                composer, song, movement, *rest = filename.split('-') + [None]
                d.update({
                    'composer': composer,
                    'song_name': song,
                    'movement': movement,
                })

            # Assess the midi to guess the key
            has_key_info = all([k in d for k in ['key', 'mode']])
            if not has_key_info:
                score = music21.converter.parse(file)
                key = score.analyze('key')

                d.update({
                    'key': key.tonic.name,
                    'mode': key.mode,
                })

            # TODO renanble after testing
            # if d.get('song_text', '') == '':
            #     # TODO our 'transposed' and 'compressed' song info
            #     d['song_text'] = self.ai_text_from_file(str(file))

            # Add any remaining metadata
            d.update({
                'path': str(file),
            })

            print(filename)
            for k, v in d.items():
                print(f'  {k}: {v}')

            # add the dict keyed under the name
            self.corpus_dict[filename] = d

    def to_yaml(self):
        """
        once we have processed the midi data info into a dict,
        we can save it out to a yaml for easy loading later
        """
        with open('corpus/save.yaml', 'w') as file:
            yaml.safe_dump(self.corpus_dict, file)

    def ai_text_from_corpus(self, offset=0, length=None):
        """
        Returns a string that can be used to train AI.
        TODO write definition of how string is made
        """
        pass

    def midi_from_corpus(self, filename, offset=0, length=None):
        """
        Saves a chunk of the corpus out to a midi file
        """
        pass

    def ai_text_from_file(self, midi_path):
        """
        Given a midi file, parse out the midi to a string we can store for
        later use, and later train the ai on
        """
        mid = mido.MidiFile(midi_path)

        # TODO should we grab the time signature?
        # Or just have everything the sane tempo?
        # Or a meta character for time signature?

        ai_text = ''
        notes_on = []
        note_events = [
            msg for msg in mido.merge_tracks(mid.tracks)
            if msg.type == 'note_on'
        ]
        for note_event in note_events:
            # Add the notes that are currently being played, for the time
            # they are currently played
            chord_chars = [
                self.char_keyboard[note] for note in notes_on
            ] + [' ']
            chord_chars *= note_event.time

            ai_text += ''.join(chord_chars)

            # TODO can we add a few levels of velocity?
            if note_event.velocity > 0:
                notes_on.append(note_event.note)
            else:
                notes_on.remove(note_event.note)

        assert notes_on == []

        return ai_text

    def midi_from_ai_text(self, filename, text):
        """
        Converts text from corpus, or generated by ai,
        back into listen-able midi
        """

        # Mapping from chars back to notes
        rev_char_keyboard = {
            v: k for k, v in self.char_keyboard.items()
        }

        mid = mido.MidiFile()
        track = mido.MidiTrack()
        mid.tracks.append(track)

        notes_on = []  # Notes being played at that tick (list of chars)
        self.time_since_last = 0  # Time since last midi event

        # Helper to add a midi event to track
        def add_event(note_char, vel=0):
            note_number = rev_char_keyboard[note_char]
            # TODO for now, max all velocity
            track.append(mido.Message(
                'note_on', note=note_number,
                velocity=vel, time=self.time_since_last
            ))
            self.time_since_last = 0

        # Loop through the ai string
        for tick in text.split(' '):
            curr_notes = [t for t in tick]

            new_notes = [n for n in curr_notes if n not in notes_on]
            removed_notes = [n for n in notes_on if n not in curr_notes]

            # Add new notes
            notes_on += new_notes
            # Remove old
            [notes_on.remove(n) for n in removed_notes]

            # Add events for note on / off
            for n in new_notes:
                add_event(n, vel=127)

            for n in removed_notes:
                add_event(n)

            self.time_since_last += 1

        # Song is over, remove any trailing notes
        for n in notes_on:
            add_event(n)

        mid.save(filename)


def collect_cleaned_midi():
    """
    Corpus has cleaned midi files, but also a ton of less useful data,
    so we use this to pull out only the clean midi we need
    """
    for dirpath, dirnames, filenames in os.walk("corpus"):
        midi_files = [f for f in filenames if f.endswith("midi_cleaned.mid")]
        for filename in midi_files:
            in_path = os.path.join(dirpath, filename)
            print('Copying', in_path)

            # Get info from path name
            _, _, composer, name, movement, *rest = in_path.split('/')
            info = [
                i for i in [composer, name, movement]
                if i != 'midi_cleaned.mid'
            ]

            # Create new path name
            new_name = '-'.join(info)
            out_path = f'./corpus/cleaned/{new_name}.mid'
            print('to', out_path)
            print()

            copyfile(in_path, out_path)


# For testing
if __name__ == '__main__':
    c = Corpus()

    test_path = 'corpus/cleaned/Chopin-Ballades-1.mid'
    t = c.ai_text_from_file(test_path)
    print(f'Returned text ({len(t)}): {t[:50]}')
    c.midi_from_ai_text('output/test.mid', t)
